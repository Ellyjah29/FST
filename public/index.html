<script>
  const tg = window.Telegram.WebApp;
  tg.expand();
  tg.ready();

  const initData = tg.initDataUnsafe;
  const telegramUser = initData?.user;
  const userId = telegramUser ? telegramUser.id.toString() : 'guest_' + Date.now();

  const topUserAvatar = document.getElementById('topUserAvatar');
  const topUserName = document.getElementById('topUserName');
  const joinView = document.getElementById('joinView');
  const teamView = document.getElementById('teamView');
  const joinContestBtn = document.getElementById('joinContest');
  const submitTeamBtn = document.getElementById('submitTeam');
  const playerModal = document.getElementById('playerModal');
  const closeModal = document.getElementById('closeModal');
  const playerList = document.getElementById('playerList');
  const teamGrid = document.getElementById('teamGrid');
  const managerNameInput = document.getElementById('managerNameInput');

  if (telegramUser) {
    topUserName.innerText = telegramUser.first_name || "FST Manager";
    if (telegramUser.photo_url) {
      topUserAvatar.src = telegramUser.photo_url;
    }
  }

  const formations = {
    "4-3-3": [1, 4, 3, 3],
    "3-5-2": [1, 3, 5, 2],
    "4-4-2": [1, 4, 4, 2],
    "5-3-2": [1, 5, 3, 2]
  };

  let currentFormation = "4-3-3";
  let selectedTeam = Array(11).fill(null);
  let allPlayers = [];
  let gameweekData = {
    current: null,
    next: null,
    matches: []
  };

  managerNameInput.value = telegramUser?.first_name || "FST Manager";

  // REAL-TIME FPL DATA
  async function fetchFplData() {
    try {
      const response = await fetch('/players');
      const data = await response.json();
      gameweekData = data.gameweek;
      
      // Update deadline countdown
      if (gameweekData.next && gameweekData.next.deadline_time) {
        updateDeadlineCountdown(gameweekData.next.deadline_time);
      }
      
      // Update gamemode progress
      if (gameweekData.current && gameweekData.next) {
        const currentGw = gameweekData.current.id;
        const nextGw = gameweekData.next.id;
        const totalGws = 38;
        
        // Calculate progress (simplified)
        const progress = ((currentGw - 1) / totalGws) * 100;
        document.getElementById('gamemodeProgress').style.width = `${progress}%`;
      }
      
      // Update player statuses
      if (allPlayers.length > 0 && gameweekData.matches) {
        updatePlayerStatuses();
      }
      
      return data.players;
    } catch (e) {
      console.error("Failed to fetch FPL data:", e);
      return [];
    }
  }

  function updateDeadlineCountdown(deadlineTime) {
    const deadline = new Date(deadlineTime);
    
    function updateTimer() {
      const now = new Date();
      const diff = deadline - now;
      
      if (diff <= 0) {
        document.getElementById('deadline-timer').innerText = "LIVE";
        document.getElementById('deadline-timer').classList.add('deadline-live');
        return;
      }
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      
      document.getElementById('deadline-timer').innerText = `${hours}h ${minutes}m`;
      
      // Change color when < 2 hours
      const timerElement = document.getElementById('deadline-timer');
      timerElement.classList.remove('deadline-live');
      
      if (diff < 2 * 60 * 60 * 1000) {
        timerElement.style.color = 'var(--error)';
      } else if (diff < 12 * 60 * 60 * 1000) {
        timerElement.style.color = 'var(--warning)';
      } else {
        timerElement.style.color = 'var(--accent)';
      }
      
      setTimeout(updateTimer, 60000); // Update every minute
    }
    
    updateTimer();
  }

  function updatePlayerStatuses() {
    const now = new Date();
    
    document.querySelectorAll('.player-card').forEach(card => {
      const playerId = parseInt(card.dataset.id);
      const player = allPlayers.find(p => p.id === playerId);
      
      if (!player) return;
      
      // Reset status
      card.classList.remove('live', 'injured', 'suspended');
      
      // Add status indicators
      if (player.status === 'i') {
        card.classList.add('injured');
      } else if (player.status === 's') {
        card.classList.add('suspended');
      }
      
      // Check if player is in an active match
      const activeMatch = gameweekData.matches.some(match => 
        match.event === gameweekData.current?.id && 
        match.started === true &&
        (match.team_h === player.team || match.team_a === player.team)
      );
      
      if (activeMatch) {
        card.classList.add('live');
        card.querySelector('.player-name').style.color = 'var(--success)';
      }
    });
  }

  function calculateTacticalAnalysis() {
    if (selectedTeam.some(p => p === null)) {
      document.getElementById('tacticalAnalysis').style.display = 'none';
      return;
    }

    // Calculate team strength (simplified version)
    const validPlayers = selectedTeam.filter(p => p !== null);
    const teamValue = validPlayers.reduce((sum, p) => sum + parseFloat(p.now_cost || 0), 0);
    const avgForm = validPlayers.reduce((sum, p) => sum + parseFloat(p.form || 0), 0) / validPlayers.length;
    const totalPoints = validPlayers.reduce((sum, p) => sum + (p.total_points || 0), 0);
    
    // Real-world formula would be more complex
    const teamStrength = Math.min(100, Math.floor(
      (avgForm * 10) + 
      (totalPoints / 11) + 
      (teamValue > 95 ? 5 : 0)
    ));

    // Calculate position balance
    const positionCounts = { gk: 0, def: 0, mid: 0, fwd: 0 };
    validPlayers.forEach(player => {
      if (player.element_type === 1) positionCounts.gk++;
      if (player.element_type === 2) positionCounts.def++;
      if (player.element_type === 3) positionCounts.mid++;
      if (player.element_type === 4) positionCounts.fwd++;
    });

    // Display results
    document.getElementById('teamStrength').innerText = `${teamStrength}/100`;
    
    // Best substitutes (simplified)
    const bestSubs = Math.min(3, 11 - validPlayers.length);
    document.getElementById('bestSubs').innerText = `${bestSubs} player${bestSubs !== 1 ? 's' : ''}`;
    
    // Position balance is handled in the UI
    document.getElementById('tacticalAnalysis').style.display = 'block';
  }

  // CONFETTI FUNCTION
  function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.style.position = 'fixed';
    confettiContainer.style.top = '0';
    confettiContainer.style.left = '0';
    confettiContainer.style.width = '100%';
    confettiContainer.style.height = '100%';
    confettiContainer.style.pointerEvents = 'none';
    confettiContainer.style.zIndex = '3000';
    document.body.appendChild(confettiContainer);

    const colors = ['#00c3ff', '#4ecdc4', '#4ade80', '#fbbf24', '#f87171'];
    const pieces = 150;

    for (let i = 0; i < pieces; i++) {
      const piece = document.createElement('div');
      piece.className = 'confetti-piece';
      piece.style.left = Math.random() * 100 + 'vw';
      piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      piece.style.width = Math.random() * 10 + 5 + 'px';
      piece.style.height = Math.random() * 10 + 5 + 'px';
      piece.style.animation = `confetti ${Math.random() * 3 + 2}s linear forwards`;
      piece.style.animationDelay = Math.random() * 2 + 's';
      confettiContainer.appendChild(piece);
    }

    // Remove after animation
    setTimeout(() => {
      document.body.removeChild(confettiContainer);
    }, 5000);
  }

  // Check existing user on load
  async function checkExistingUser() {
    try {
      const response = await fetch(`/user-profile?userId=${userId}`);
      const profile = await response.json();
      
      if (profile.managerName && profile.joined) {
        topUserName.innerText = profile.managerName;
        
        // If team is LOCKED (submitted), show read-only view
        if (profile.locked) {
          joinView.style.display = 'none';
          teamView.style.display = 'block';
          loadPlayers().then(() => {
            selectedTeam = profile.team.map(id => 
              allPlayers.find(p => p.id === id) || { id, web_name: "Unknown", photo_url: "https://via.placeholder.com/60x75?text=❓" }
            );
            renderTeamGrid();
            calculateTeamStats(); // Show team stats
            // Only reduce opacity (don't disable pointer events)
            document.querySelectorAll('.slot').forEach(slot => {
              slot.style.opacity = '0.7';
            });
            submitTeamBtn.style.display = 'none';
            document.getElementById('formationSelectorContainer').style.display = 'none';
            
            // Show "Already Submitted" banner
            const banner = document.createElement('div');
            banner.innerHTML = `
              <div class="submission-banner">
                <div class="banner-title">✅ Team Submitted!</div>
                <div class="banner-text">Your team is locked for this contest.</div>
              </div>
            `;
            const firstSection = document.querySelector('.section');
            firstSection.insertBefore(banner, firstSection.firstChild);
          });
          return;
        }
        
        // If joined but not submitted, show team builder
        joinView.style.display = 'none';
        teamView.style.display = 'block';
        loadPlayers();
        if (profile.team && profile.team.length > 0) {
          selectedTeam = profile.team.map(id => 
            allPlayers.find(p => p.id === id) || { id, web_name: "Unknown", photo_url: "https://via.placeholder.com/60x75?text=❓" }
          );
        }
        renderTeamGrid();
        calculateTeamStats(); // Show team stats
        return;
      }
    } catch (e) {
      // Continue to join view
    }
    
    managerNameInput.value = telegramUser?.first_name || "FST Manager";
  }

  // Initialize
  checkExistingUser().then(() => {
    setupTeamGridEvents();
  });

  function setupTeamGridEvents() {
    document.querySelectorAll('.slot').forEach(slot => {
      // Remove any existing handler
      if (slot.clickHandler) {
        slot.removeEventListener('click', slot.clickHandler);
      }
      
      // Create new handler
      slot.clickHandler = function() {
        const index = slot.dataset.index;
        const player = selectedTeam[index];
        
        // If team is submitted and player exists, show stats
        if (player && player.id && submitTeamBtn.style.display === 'none') {
          showPlayerStats(player);
          return;
        }
        
        // For non-submitted teams, allow selection on empty slots
        if (submitTeamBtn.style.display !== 'none' && !player) {
          const type = slot.dataset.type;
          openPlayerModal(type, index);
          
          // Add selection animation
          slot.style.transform = 'scale(0.95)';
          setTimeout(() => {
            slot.style.transform = '';
          }, 150);
        }
      };
      
      slot.addEventListener('click', slot.clickHandler);
    });
  }

  function openPlayerModal(positionType, slotIndex) {
    const positionMap = { gk: 1, def: 2, mid: 3, fwd: 4 };
    const fplType = positionMap[positionType];
    const positionName = { gk: 'Goalkeeper', def: 'Defender', mid: 'Midfielder', fwd: 'Forward' }[positionType];

    document.getElementById('modalPosition').innerText = positionName;

    // Get currently selected player IDs
    const selectedIds = new Set(
      selectedTeam
        .filter(p => p !== null)
        .map(p => p.id)
    );

    // Get available players for this position
    let availablePlayers = allPlayers
      .filter(p => p.element_type === fplType)
      .filter(p => {
        // Include the currently selected player in the modal
        const isCurrentSlot = selectedTeam[slotIndex] && selectedTeam[slotIndex].id === p.id;
        return isCurrentSlot || !selectedIds.has(p.id);
      });

    // Render the player list
    renderPlayerList(availablePlayers, slotIndex);
    playerModal.style.display = 'flex';
    playerModal.classList.add('slide-in-up');
  }

  // Add this function to handle player selection
  function handlePlayerSelection(playerId, slotIndex) {
    const player = allPlayers.find(p => p.id === playerId);
    
    // Clear previous selection of this player
    for (let i = 0; i < selectedTeam.length; i++) {
      if (selectedTeam[i] && selectedTeam[i].id === playerId) {
        selectedTeam[i] = null;
      }
    }
    
    // Set new selection
    selectedTeam[slotIndex] = player;
    
    // Update UI
    renderTeamGrid();
    playerModal.style.display = 'none';
  }

  function renderPlayerList(players, slotIndex) {
    let html = '';
    players.forEach(player => {
      // Determine status
      let statusIndicator = '';
      if (player.status === 'i') {
        statusIndicator = `<span class="player-status" style="color:var(--error); font-weight:600;">(Injured)</span>`;
      } else if (player.status === 's') {
        statusIndicator = `<span class="player-status" style="color:var(--warning); font-weight:600;">(Suspended)</span>`;
      }
      
      // Check if player is in live match
      let liveIndicator = '';
      if (gameweekData.matches) {
        const isLive = gameweekData.matches.some(match => 
          match.event === gameweekData.current?.id && 
          match.started === true &&
          (match.team_h === player.team || match.team_a === player.team)
        );
        
        if (isLive) {
          liveIndicator = `<span class="live-indicator"></span>`;
        }
      }
      
      // Check if this is the currently selected player for this slot
      const isSelected = selectedTeam[slotIndex] && selectedTeam[slotIndex].id === player.id;
      
      html += `
        <div class="player-card ${player.status === 'i' ? 'injured' : ''} ${player.status === 's' ? 'suspended' : ''} ${isSelected ? 'selected' : ''}">
          ${liveIndicator}
          ${isSelected ? '<div style="position: absolute; top: 2px; right: 2px; background: var(--primary); color: #000; width: 16px; height: 16px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 12px;">✓</div>' : ''}
          <img src="${player.photo_url}" class="player-photo" onerror="this.src='https://via.placeholder.com/60x75?text=❓'">
          <div class="player-info">
            <div class="player-name">${player.web_name} ${statusIndicator}</div>
            <div class="player-meta">
              <span>${player.team_name}</span>
              <span class="price-tag">£${player.now_cost}m</span>
              <span class="points-tag">${player.total_points} pts</span>
            </div>
          </div>
        </div>
      `;
    });

    if (players.length === 0) {
      html = '<div class="empty-state"><i class="fas fa-search"></i><p>No players match your filters</p></div>';
    }

    playerList.innerHTML = html;

    // Set up click handlers for all cards
    document.querySelectorAll('.player-card').forEach(card => {
      card.addEventListener('click', () => {
        const playerId = parseInt(card.dataset.id);
        handlePlayerSelection(playerId, slotIndex);
      });
    });
  }

  joinContestBtn.addEventListener('click', async () => {
    const managerName = managerNameInput.value.trim() || "FST Manager";
    if (managerName.length < 2) {
      alert("Manager name must be at least 2 characters");
      return;
    }

    try {
      const response = await fetch('/connect-wallet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, managerName })
      });
      const data = await response.json();
      if (data.success) {
        topUserName.innerText = data.managerName;
        joinView.style.display = 'none';
        teamView.style.display = 'block';
        loadPlayers();
        renderTeamGrid();
      } else {
        throw new Error(data.error || 'Failed to join');
      }
    } catch (e) {
      alert("Error: " + (e.message || "Failed to join contest"));
    }
  });

  async function loadPlayers() {
    const statusDiv = document.getElementById('status') || document.createElement('div');
    if (!document.getElementById('status')) {
      const firstSection = document.querySelector('.section');
      firstSection.insertBefore(statusDiv, firstSection.firstChild);
      statusDiv.id = 'status';
    }

    // Show skeleton loading
    teamGrid.innerHTML = `
      <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:16px;">
        ${Array(8).fill().map(() => `
          <div class="skeleton" style="height:80px; border-radius:14px;"></div>
        `).join('')}
      </div>
    `;

    try {
      const players = await fetchFplData();
      allPlayers = players;
      statusDiv.innerText = "";
      renderTeamGrid();
    } catch (e) {
      teamGrid.innerHTML = ''; // Clear skeleton on error
      statusDiv.innerHTML = `
        ❌ ${e.message}<br>
        <button class="retry-btn" id="retryBtn">
          <i class="fas fa-redo"></i> Retry
        </button>
      `;
      document.getElementById('retryBtn').addEventListener('click', loadPlayers);
    }
  }

  function renderTeamGrid() {
    const [gk, def, mid, fwd] = formations[currentFormation];
    const slots = [];
    
    for (let i = 0; i < gk; i++) slots.push({ type: 'gk', label: 'GK' });
    for (let i = 0; i < def; i++) slots.push({ type: 'def', label: 'DEF' });
    for (let i = 0; i < mid; i++) slots.push({ type: 'mid', label: 'MID' });
    for (let i = 0; i < fwd; i++) slots.push({ type: 'fwd', label: 'FWD' });

    let html = '';
    const lines = [
      slots.slice(-fwd),
      slots.slice(-(fwd+mid), -fwd),
      slots.slice(-(fwd+mid+def), -(fwd+mid)),
      slots.slice(0, gk)
    ];

    lines.forEach(line => {
      if (line.length === 0) return;
      html += `<div class="line">`;
      line.forEach((slot, idx) => {
        const slotIndex = slots.indexOf(slot);
        const player = selectedTeam[slotIndex];
        html += `
          <div class="slot ${slot.type} ${player ? 'filled' : ''}" 
               data-index="${slotIndex}" 
               data-type="${slot.type}">
            ${player ? 
              `<img src="${player.photo_url}" style="width:50px;height:62px;object-fit:cover;border-radius:8px;">` : 
              `<span class="slot-label">${slot.label}</span>`
            }
          </div>
        `;
      });
      html += `</div>`;
    });

    teamGrid.innerHTML = html;
    
    // Update event listeners
    setupTeamGridEvents();
    
    checkSubmitButton();
    calculateTeamStats(); // Update team stats
    
    // Update progress bar
    const filledCount = selectedTeam.filter(p => p !== null).length;
    const progressPercent = (filledCount / 11) * 100;
    document.getElementById('teamProgress').style.width = `${progressPercent}%`;
    document.getElementById('teamProgressText').innerText = `${filledCount}/11 players selected`;
    
    // ✅ HIDE FORMATION FOR SUBMITTED TEAMS
    const isSubmitted = submitTeamBtn.style.display === 'none';
    const formationContainer = document.getElementById('formationSelectorContainer');
    if (formationContainer) {
      formationContainer.style.display = isSubmitted ? 'none' : 'block';
    }
  }

  function showPlayerStats(player) {
    const statsContent = document.getElementById('statsContent');
    
    // Position-specific stats
    let positionStats = '';
    if (player.element_type === 1 || player.element_type === 2) { // GK/DEF
      positionStats = `
        <div class="stat-row">
          <span>Clean Sheets:</span>
          <span>${player.clean_sheets}</span>
        </div>
      `;
    }
    
    // Check match status
    let matchStatus = '';
    if (gameweekData.matches) {
      const match = gameweekData.matches.find(m => 
        (m.team_h === player.team || m.team_a === player.team) && 
        m.event === gameweekData.current?.id
      );
      
      if (match) {
        if (match.finished) {
          matchStatus = `<span class="match-status finished">FT</span>`;
        } else if (match.started) {
          matchStatus = `<span class="match-status live">${match.minutes}'</span>`;
        } else {
          const date = new Date(match.kickoff_time);
          matchStatus = `<span class="match-status">${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}</span>`;
        }
      }
    }
    
    statsContent.innerHTML = `
      <div style="text-align:center; margin-bottom:20px;">
        <img src="${player.photo_url}" style="width:80px; height:100px; border-radius:10px; object-fit:cover;">
        <h3 style="margin:10px 0; color: var(--text);">${player.web_name} ${matchStatus}</h3>
        <div style="color:var(--text-tertiary);">${player.team_name} • ${player.position}</div>
        <div style="color:var(--success); font-weight:700; font-size:18px; margin-top:5px;">${player.total_points} pts</div>
      </div>
      
      <div class="stat-grid">
        <div class="stat-row">
          <span>Form:</span>
          <span>${player.form}</span>
        </div>
        <div class="stat-row">
          <span>Pts/Game:</span>
          <span>${player.points_per_game}</span>
        </div>
        <div class="stat-row">
          <span>Selected By:</span>
          <span>${player.selected_by_percent}%</span>
        </div>
        <div class="stat-row">
          <span>Minutes:</span>
          <span>${player.minutes}</span>
        </div>
        <div class="stat-row">
          <span>Goals:</span>
          <span>${player.goals_scored}</span>
        </div>
        <div class="stat-row">
          <span>Assists:</span>
          <span>${player.assists}</span>
        </div>
        <div class="stat-row">
          <span>Bonus:</span>
          <span>${player.bonus}</span>
        </div>
        ${positionStats}
      </div>
      
      <div style="margin-top:20px; padding-top:15px; border-top:1px solid var(--border);">
        <div style="color:var(--text-tertiary); font-size:13px;">
          * Stats updated after each gameweek
        </div>
      </div>
    `;
    
    document.getElementById('statsModal').style.display = 'flex';
    document.getElementById('statsModal').classList.add('slide-in-up');
  }

  function calculateTeamStats() {
    if (selectedTeam.some(p => p === null)) {
      document.getElementById('teamStats').style.display = 'none';
      return;
    }
    
    const validPlayers = selectedTeam.filter(p => p !== null);
    const totalPoints = validPlayers.reduce((sum, p) => sum + (p.total_points || 0), 0);
    const teamValue = validPlayers.reduce((sum, p) => sum + parseFloat(p.now_cost || 0), 0);
    const avgForm = validPlayers.reduce((sum, p) => sum + parseFloat(p.form || 0), 0) / validPlayers.length;
    const avgPPG = validPlayers.reduce((sum, p) => sum + parseFloat(p.points_per_game || 0), 0) / validPlayers.length;
    
    // Add fade-in animation to stats cards
    const statsContainer = document.getElementById('teamStats');
    statsContainer.style.display = 'block';
    
    // Animate stat values
    animateValue('totalPoints', 0, totalPoints, 1000);
    animateValue('teamValue', 0, teamValue, 1000, (val) => `£${val.toFixed(1)}m`);
    animateValue('avgForm', 0, avgForm, 800, (val) => val.toFixed(1));
    animateValue('avgPPG', 0, avgPPG, 800, (val) => val.toFixed(1));
  }

  function animateValue(id, start, end, duration, formatter = (val) => Math.round(val)) {
    const element = document.getElementById(id);
    const range = end - start;
    let current = start;
    const increment = end > start ? 1 : -1;
    const stepTime = Math.abs(Math.floor(duration / range));
    const timer = setInterval(() => {
      current += increment;
      if (current >= end) {
        clearInterval(timer);
        element.innerText = formatter(end);
      } else {
        element.innerText = formatter(current);
      }
    }, stepTime);
  }

  closeModal.addEventListener('click', () => {
    playerModal.classList.remove('slide-in-up');
    setTimeout(() => {
      playerModal.style.display = 'none';
    }, 300);
  });

  document.getElementById('closeStatsModal').addEventListener('click', () => {
    document.getElementById('statsModal').classList.remove('slide-in-up');
    setTimeout(() => {
      document.getElementById('statsModal').style.display = 'none';
    }, 300);
  });

  document.querySelectorAll('.formation-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.formation-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentFormation = btn.dataset.formation;
      selectedTeam = Array(11).fill(null);
      renderTeamGrid();
    });
  });

  submitTeamBtn.addEventListener('click', async () => {
    if (selectedTeam.some(p => p === null)) {
      alert("Please fill all 11 slots");
      return;
    }

    const teamIds = selectedTeam.map(p => p.id);
    try {
      const response = await fetch('/save-team', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, team: teamIds })
      });
      const data = await response.json();
      if (data.success) {
        // Create confetti celebration
        createConfetti();
        
        // Show success message with animation
        const successBanner = document.createElement('div');
        successBanner.innerHTML = `
          <div style="text-align:center; padding:20px; background:rgba(74, 222, 128, 0.15); border-radius:16px; margin:16px 0; animation: fadeInUp 0.5s ease-out;">
            <div style="font-size:24px; margin-bottom:8px;">🎉</div>
            <div style="font-weight:700; color:var(--success); font-size:18px; margin-bottom:6px;">Team Submitted!</div>
            <div style="color:var(--text-secondary);">Good luck in the contest!</div>
          </div>
        `;
        const firstSection = document.querySelector('.section');
        firstSection.insertBefore(successBanner, firstSection.firstChild);
        
        // Rest of your existing code...
        const response = await fetch(`/user-profile?userId=${userId}`);
        const profile = await response.json();
        selectedTeam = profile.team.map(id => 
          allPlayers.find(p => p.id === id) || { id, web_name: "Unknown", photo_url: "https://via.placeholder.com/60x75?text=❓" }
        );
        renderTeamGrid();
        calculateTeamStats();
        document.querySelectorAll('.slot').forEach(slot => {
          slot.style.opacity = '0.7';
        });
        submitTeamBtn.style.display = 'none';
        document.getElementById('formationSelectorContainer').style.display = 'none';
        
        // Auto-hide success banner after 3 seconds
        setTimeout(() => {
          if (successBanner.parentNode) {
            successBanner.parentNode.removeChild(successBanner);
          }
        }, 3000);
      }
    } catch (e) {
      alert("Failed to submit team: " + (e.message || ""));
    }
  });

  function checkSubmitButton() {
    const isComplete = !selectedTeam.some(p => p === null);
    submitTeamBtn.disabled = !isComplete;
  }

  // Initialize real-time data
  loadPlayers();
</script>
